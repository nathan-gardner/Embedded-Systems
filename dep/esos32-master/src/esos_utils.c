/*
 * "Copyright (c) 2019 J. W. Bruce ("AUTHOR(S)")"
 * All rights reserved.
 * (J. W. Bruce, jwbruce_AT_tntech.edu, Tennessee Tech University)
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice, the following
 * two paragraphs and the authors appear in all copies of this software.
 *
 * IN NO EVENT SHALL THE "AUTHORS" BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE "AUTHORS"
 * HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE "AUTHORS" SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE "AUTHORS" HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS."
 *
 * Please maintain this header in its entirety when copying/modifying
 * these files.
 *
 *
 */

/** \file
 * \brief Various hardware independent utilties for ESOS32 and its user applications
 *
 */


#include    "esos.h"
#include    "esos_utils.h"

// ******** G L O B A L S ***************
uint32_t            __u32_esos_PRNG_Seed;
uint32_t            __esos_u32FNVHash = 2166136261uL;

/****************************************************************
** F U N C T I O N S
****************************************************************/

/**
* Writes message data to a task's mailbox.
*
* \param pst_RcvrTask  pointer to task structure (ESOS_TASK_HANDLE) whose mailbox will be written
* \param pst_Msg        pointer to mailbox message structure that contains data to write to the task's mailbox
* \note This function <em>ASSUMES</em> that there is ample free space available in specified
* mailbox.
*
* \sa ESOS_TASK_WAIT_ON_TASKS_MAILBOX_HAS_SPACE
* \hideinitializer
*/


/**
 * Sets the seed value in the ESOS pseudo-random number generator (PRNG).
 * \note ESOS init code sets a seed value for the PRNG.  If the application
 * desires a sequence that is not predictable at each execution run,
 * then the seed should be set <em>ONCE</em> with some value that is
 * different with each execution.  An idea is to have the user press
 * a key during startup.  The value of the ESOS tick when the user presses
 * the key will be different each time.  This number would make an
 * ideal PRNG seed.
 * \sa __esos_GetSWRNGRandomUint32
 * See http://www.firstpr.com.au/dsp/rand31/  for more information
 */
void __esos_set_PRNG_U32Seed(uint32_t u32_seed) {
   __u32_esos_PRNG_Seed = u32_seed;
} // end __esos_set_PRNG_U32Seed()

/**
* Returns a 31-bit pseudo-random number generated by the Park-Miller
* algorithm.
 * \sa __esos_setSWRNGU32Seed
* \note Visit http://www.firstpr.com.au/dsp/rand31/ for more information
*/
uint32_t   __esos_get_PRNG_RandomUint32(void) {
  uint32_t  hi, lo;

  lo = 16807 * ( __u32_esos_PRNG_Seed * 0xFFFF );
  hi = 16807 * ( __u32_esos_PRNG_Seed >> 16 );
  lo += (hi & 0x7FFF) << 16;
  lo += (hi >> 15);
  if (lo > 0x7FFFFFFF) lo -= 0x7FFFFFFF;
  return (__u32_esos_PRNG_Seed = (uint32_t) lo );
} // end __esos_get_PRNG_RandomUint32()

/**
* Returns a 32-bit pseudo-random number.  Will call a "hw" RNG
* function to allow for HW PRNG if available.  If HW is not present,
* the hardware specific (hwxxx or others) can simply call back to
* the hidden ESOS function above: __esos_GetSWRNGRandomUint32 
 * \sa __esos_setSWRNGU32Seed
 * \sa __esos_GetSWRNGRandomUint32
* \note Visit http://www.firstpr.com.au/dsp/rand31/ for more information
*/
inline uint32_t    esos_GetRandomUint32(void) {
  return ( __esos_hw_PRNG_u32() );
} // end esos_getRandomUint32()


/** ********************************************************************
*
*
***********************************************************************/
uint16_t    esos_taskname_hash_u16( void* buf, uint16_t len ) {
  unsigned char *bp = (unsigned char *)buf; /* start of buffer */
  unsigned char *be = bp + len;   /* beyond end of buffer */
  uint32_t        u32_temp = 2166136261uL;

  /*
   * FNV-1 hash each octet in the buffer
   */
  while (bp < be) {
    /* multiply by the 32 bit FNV magic prime mod 2^32 */
    u32_temp += (u32_temp<<1) + (u32_temp<<4) + (u32_temp<<7) + (u32_temp<<8) + (u32_temp<<24);

    /* xor the bottom with the current octet */
    u32_temp ^= (uint32_t)*bp++;
  } // end while
  return (uint16_t) ((u32_temp >> 16) ^ (u32_temp & 0xFFFF));
} // end esos_taskname_hash_u16


/**
 * Create a 32-bit (uint32_t) hash value for a buffer of voids
 * Routine maintains "state" in the form of variable __esos_u32FNVHash
 * This "state" is used in all of the ESOS FNV hash functions.
 * Based on the Fowler/Noll/Vo (FNV1a) hash algorithm and code provided
 * at http://www.isthe.com/chongo/tech/comp/fnv/
 * \param buf pointer to a buffer of voids
 * \param len length of the buffer of voids
 * \retval uint32_t value of the resulting hash
 *  \sa esos_string_hash_u32
 *  \sa esos_hash_u32_to_u16
*/
uint32_t esos_buffer_hash_u32(void *buf, uint16_t len) {
  unsigned char *bp = (unsigned char *)buf; /* start of buffer */
  unsigned char *be = bp + len;           /* beyond end of buffer */

  /*
   * FNV-1 hash each octet in the buffer
   */
  while (bp < be) {

    /* multiply by the 32 bit FNV magic prime mod 2^32 */
#if defined(NO_FNV_GCC_OPTIMIZATION)
    __esos_u32FNVHash *= FNV_32_PRIME;
#else
    __esos_u32FNVHash += (__esos_u32FNVHash<<1) + (__esos_u32FNVHash<<4) + (__esos_u32FNVHash<<7) + (__esos_u32FNVHash<<8) + (__esos_u32FNVHash<<24);
#endif

    /* xor the bottom with the current octet */
    __esos_u32FNVHash ^= (uint32_t)*bp++;
  }

  /* return our new hash value */
  return __esos_u32FNVHash;
}


/**
 * Create a 32-bit (uint32_t) hash value for a provided string
 * Routine maintains "state" in the form of variable __esos_u32FNVHash
 * This "state" is used in all of the ESOS FNV hash functions.
 * Based on the Fowler/Noll/Vo (FNV1a) hash algorithm and code provided
 * at http://www.isthe.com/chongo/tech/comp/fnv/
 * \param psz_str pointer to zero-terminated string
 * \retval uint32_t value of the resulting hash
 *  \sa esos_string_hash_u32
 *  \sa esos_hash_u32_to_u16
*/
uint32_t esos_string_hash_u32(char *psz_str) {
  unsigned char *ch_s = (unsigned char *)psz_str; /* unsigned string */

  /*
   * FNV-1 hash each octet in the buffer
   */
  while (*ch_s) {

    /* multiply by the 32 bit FNV magic prime mod 2^32 */
#if defined(NO_FNV_GCC_OPTIMIZATION)
    __esos_u32FNVHash *= FNV_32_PRIME;
#else
    __esos_u32FNVHash += (__esos_u32FNVHash<<1) + (__esos_u32FNVHash<<4) + (__esos_u32FNVHash<<7) + (__esos_u32FNVHash<<8) + (__esos_u32FNVHash<<24);
#endif

    /* xor the bottom with the current octet */
    __esos_u32FNVHash ^= (uint32_t)*ch_s++;
  }

  /* return our new hash value */
  return __esos_u32FNVHash;
}

inline uint16_t esos_hash_u32_to_u16(uint32_t u32_hash) {
  return  (uint16_t) ((u32_hash>>16) ^ (u32_hash&0xFFFF));
}

